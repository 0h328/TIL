# ì¬ê·€

> í•¨ê»˜ í•™ìŠµí•˜ê³  ê³ ë¯¼í•˜ê³  ì„¤ëª…í•˜ë©° ì‘ì€ ë¶€ë¶„ í•˜ë‚˜ë¼ë„ 'ë‚´ ê²ƒ'ìœ¼ë¡œ ë§Œë“¤ì–´ë³´ì„¸ìš”. ğŸ˜




## 2ë²ˆ - Merge Sort Time Complexity Proof

![5-2(1)](5_ì¬ê·€.assets/5-2(1).jpg)



![5-2(2)](5_ì¬ê·€.assets/5-2(2).jpg)



## 4ë²ˆ 

![5-4](5_ì¬ê·€.assets/5-4.jpg)

## 6ë²ˆ

ì €í¬ ì¡°ë¼ë¦¬ í•´ê²°í•´ë³´ë ¤ë‹¤ í¬ê¸°í•˜ê³  ë”°ë¼ì³¤ìŠµë‹ˆë‹¤...

```python
def recursion(node, ancestors, generations):
    if node in tree:
        for i, child in enumerate(tree[node], start = 1):
            recursion(child, ancestors + [node], generations + [i])
    else:
        ancestors += [node]
        rtn = f'[{str(ancestors[0]).zfill(3)}]' if not printed else '     '

        for i , ancestor in enumerate(ancestors[1:], start = 1):
            if ancestor in printed:
                rtn +='   |        '
            else:
                sibling_count = len(tree[ancestors[i-1]])
                sibling_rank = generations[i]
                number = str(ancestor).zfill(3)

                if sibling_count == 1:
                    rtn += f' ----- [{number}]'
                elif sibling_rank == 1:
                    rtn += f' --+-- [{number}]'
                elif sibling_count ==sibling_rank:
                    rtn += f'   L-- [{number}]'
                else:
                    rtn += f'   +-- [{number}]'

                printed.add(ancestor)
        print(rtn)


tree = {}
edges = list(map(int, input().split()))
# 30 54 30 2 30 45 54 1 54 3 45 123 1 101 1 102 3 103

for i in range(0, len(edges)-1, 2):
    tree[edges[i]] = tree.get(edges[i],[]) + [edges[i + 1]]

printed = set()
recursion(edges[0], [], [1])
```

